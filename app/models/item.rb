class Item < ApplicationRecord
  #attr_accessible :title, :unique_id, :item_type, :callnumber, :author, :isbn, :publisher, :published_date,
  #                :language_note, :edition, :physical_description, :source, :source_note

  include SearchCop

  search_scope :search do
    attributes :title, :callnumber, :author, :isbn, :publisher
    #attributes student: ["students.first_name", "students.last_name"]
    #attributes course: "courses.code"
    attributes creator: ["user.first_name", "user.last_name"]
  end

  audited
  has_associated_audits
  paginates_per 20

  ## VALIDATIONS ##
  validates_presence_of :title, :item_type
  validates_uniqueness_of :unique_id
  validates :physical_description, length: { maximum: 250 }
  validates :language_note, length: { maximum: 250 }
  validates :edition, length: { maximum: 250 }
  validates :source, length: { maximum: 250 }
  validates :source_note, length: { maximum: 250 }
  validates :publisher, length: { maximum: 250 }
  validates :isbn, length: { maximum: 250 }
  validates :callnumber, length: { maximum: 250 }
  validates :title, length: { maximum: 250 }
  validates :author, length: { maximum: 250 }

  ## RELATIONS ##

  has_many :attachments

  has_many :item_connections
  # has_many :students, :through => :item_connections, :conditions =>  [ "item_connections.expires_on >= ? OR item_connections.expires_on IS ?", Date.today, nil]
  has_many :students, -> { where("item_connections.expires_on >= ? OR item_connections.expires_on IS ?", Date.today, nil) }, :through => :item_connections

  has_many :item_course_connections
  has_many :courses, through: :item_course_connections

  has_many :acquisition_requests

  belongs_to :user

  has_many :scan_items
  has_many :scan_lists, through: :scan_items

  ## SCOPES ##

  scope :by_date, -> { order("items.created_at desc") }
  scope :alphabetical, -> { order("items.title asc") }

  scope :recently_worked_with, lambda { |user_id|
    joins("INNER JOIN audits ON (audits.auditable_id = items.id OR audits.associated_id = items.id) AND (audits.auditable_type = 'Item' OR audits.associated_type = 'Item')")
    .where("audits.user_id = ?", user_id).reorder("audits.created_at desc").group("items.id") }

  ## CONSTANTS
  BOOK = "book"
  COURSE_KIT = "course_kit"
  ARTICLE = "article"
  TYPES = [[BOOK.titleize, BOOK], [COURSE_KIT.titleize, COURSE_KIT], [ARTICLE.titleize, ARTICLE]]


  ## ACCESSORS
  attr_accessor :acquisition_request, :expired


  ## AFTER CREATE UPDATE THE UNIQUE ID to use the autogenerated id
  after_create do
    if self.unique_id.blank?
      self.unique_id = "uid-#{self.id}"
      self.audit_comment = "Created unique ID"
      save(validate: false)
    end
  end



  def assign_to_student(student, expire_on = nil)
    existing_connection = ItemConnection.where("student_id = ? AND item_id = ? AND (expires_on >= ? OR expires_on IS ?)", student.id, self.id, Date.today, nil).first

    # if we have an item_connection that has been expired, update it
    if existing_connection
     existing_connection.audit_comment = "Renewing until #{expire_on}"
     existing_connection.expires_on = expire_on
     existing_connection.save
    else
     # No existing conneciton, make a new one.
     connection = ItemConnection.new
     connection.student = student
     connection.expires_on = expire_on unless expire_on.nil?
     connection.item = self
     connection.audit_comment = "Assigned - #{self.title[0...240]}"
     connection.save

     "NEW CONNECTION"
    end
  end

  def withhold_from_student(student)
     # remove non-expired ones
     connection = ItemConnection.where("student_id = ? AND item_id = ? AND (expires_on >= ? OR expires_on IS ?)", student.id, self.id, Date.today, nil).first

     unless connection == nil
       connection.audit_comment = "Removed #{self.title}"
       connection.destroy
     end
  end

  def touch(user_id = nil, updated_comment="Updated Item or related objects")
    if user_id
      self[:updated_by] = user_id
      self.audit_comment = updated_comment
      save(validate: false)
    end
  end
end
